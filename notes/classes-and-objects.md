# クラスとオブジェクト

クラスもまた、Javaに比べると簡潔な記述がしやすくなっている。
明示的にアクセス修飾子を指定しなければ、メンバーは全て`public`になる。

## クラスパラメータ
Javaではコンストラクタがパラメータを受け取るが、Scalaはクラスが直接
パラメータを受け取る事ができる。このパラメータはクラス内で直接使用可能。
ただし、外部からアクセス可能なフィールドを作る場合にはやはり明示的に
フィールドを宣言し、そこに値を代入する必要がある。
またScalaもコンストラクタを複数持つ事ができる。基本コンストラクタ以外は
補助コンストラクタと呼ばれる。補助コンストラクタは、先頭で他のコンストラクタを
呼びださなければいけない。

## パラメータなしメソッドの定義と使用
パラメータを1つも受け取らないメソッドを宣言・定義する際、Scalaでは引数リスト(空括弧)
を省略できる。同様に、引数を受け取らないメソッドの呼び出しでも空括弧を省略する事が
できる。が、常にできるわけではない。この部分が少しわかりづらい。というのも、
メソッド呼び出し時の空括弧省略は、そのメソッドの定義に依存してしまうからである。
表にまとめると以下のようになる。

|                     | 使用時 括弧あり | 使用時 括弧なし  |
| ------------------- |:---------------:|:----------------:|
| **宣言時 括弧あり** | OK              | OK               |
| **宣言時 括弧なし** | *ERROR*         | OK               |

つまり、括弧付きで宣言されたメソッドの呼び出しでは括弧はあっても無くても良いが、括弧なしで
宣言されたメソッドの呼び出しでは必ず括弧を省略する必要がある。という事は引数を取らない
メソッドを呼び出す場合、使用者はそのメソッドが括弧つきで定義されているのかどうかを知っている
必要がある。括弧なしの呼び出しでエラーになる事はないので、確かにコップ本にある通り
「引数をとらないあらゆる関数呼び出しでは、空括弧は省略可能になっている」事にはなるが(p185)。。

これは恐らく、参照透明な関数の記法に対するこだわりなのだと思われる。空括弧の有無については、
副作用のあるメソッドの宣言や使用ではそれを明示するために空括弧を使用し、逆に副作用のない
メソッドでもまたその参照透明性を明示するために空括弧を省略する事が望ましいとある。
確かにそのルールに則ってメソッドを宣言・使用するようにすれば、そのメソッド呼び出しに
副作用があるのかどうかは一目瞭然となる。更に言えば、副作用のないメソッド呼び出しは
フィールドアクセスと同等に行われるべきだという事？ 上記のルールのもとでは、空括弧なしで
宣言されたメソッドが括弧付きで呼ばれる事はありえなくなるため、そのメソッドを後々メソッドではなく
フィールドに変更したとしても、クライアントのコードには一切影響がない(もともとの関数がきちんと参照透明であれば)。
しかし逆に、副作用のあるメソッドを括弧なしで呼ぶ事はできてしまう。。そもそも括弧の有無は
実質的にはただの記法のバリエーションであって実際の実装内容には関係ないのだから、このルールを
使う事でコードがどの程度記述的になるかは、結局のところ開発者に委ねられるのだと思われる。

[参考: 空括弧の有無による処理の違い実験](http://t-ikeda.akira.ne.jp/enter/lang/scala/doc1_my/Method_Field.html)

## 合成と継承

### 継承
基本的にはJavaと似ている。`extends`節で他のクラスを継承でき、サブクラス内でスーパークラスと同名の
フィールドやメソッドを定義すれば、それらをオーバーライドできる(ただし具象メソッド・フィールドを
オーバーライドする場合は、常に`override`修飾子が必要)。またもちろん、スーパークラスの型で宣言された変数には
サブクラスのインスタンスを代入できる。

#### 名前空間
Javaと異なるのは名前空間の切り分け方である。Scalaではフィールドとメソッドが同じ名前空間に属するため、
例えばスーパークラスで宣言されたメソッドを、フィールドとしてオーバーライドする事ができる(逆はできない(たぶん))。

Scalaの名前空間

* 値( フィールド、メソッド、パッケージ、シングルトンオブジェクト )
* 型( クラス、トレイト )

## クラスの階層構造
詳細は p.206 を参照。Scalaのクラス階層の頂点には`Any`クラスがおり、それを継承するクラスとして`AnyVal`, `AnyRef`の
2クラスが存在する。`Int`, `Char`, `Boolean`など、Javaのプリミティブ型に対応する値クラスは`AnyVal`を継承しており、
演算用のメソッドを持つ。しかし値クラス間には継承関係はなく、型の変換には暗黙の型変換が使用される。通常のクラス
(参照クラス)は全て`AnyRef`を継承する。`AnyRef`のJavaプラットフォーム上の実装形態が`java.lang.Object`だと言える。
これら共通のスーパークラスとは逆に、共通のサブクラスとして定義されているのが`Null`クラスと`Nothing`である。
`Null`は全ての参照クラス(`AnyRef`のサブクラス)の共通サブクラスであり、`Nothing`は`AnyVal`、`AnyRef`、`Null`の
サブクラス(つまり正真正銘全クラスのサブクラス)となる。よって値クラスのインスタンスに`null`を代入する事はできない。
`Nothing`型の値は存在しない。例えば例外を投げるメソッドの戻り値型に使用すれば、そのメソッドはどのような型を
要求される場面でも使用できる。
